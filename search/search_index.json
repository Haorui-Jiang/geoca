{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<ul> <li>\u7b80\u4f53\u4e2d\u6587</li> </ul>"},{"location":"#welcome-to-geoca","title":"Welcome to geoca","text":"<p>A Python module for CA models based on geo-raster data</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://Haorui-Jiang.github.io/geoca</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Read raster data from a file and convert the data to a format such as a Python list.</li> <li>Creates a raster template from the input raster data and uniformly replaces the data in the corresponding position of that raster template.</li> <li>Running CA models based on raster data to analyze population and other resource migration.</li> </ul>"},{"location":"cellularautomata/","title":"cellularautomata module","text":"<ul> <li>\u7b80\u4f53\u4e2d\u6587: \u6b64\u9875\u9762\u672a\u7ffb\u8bd1\u4e3a\u7b80\u4f53\u4e2d\u6587\u3002</li> </ul>"},{"location":"cellularautomata/#cellularautomata-module","title":"cellularautomata module","text":"<p>The cellularautomata module implements a cellularautomata model for analyzing the distribution of population and other resources within a study area based on grid data.</p>"},{"location":"cellularautomata/#geoca.cellularautomata.get_neighbors","title":"<code>get_neighbors(row_now, col_now, data_list, direction_num=4)</code>","text":"<p>Get neighboring valid coordinates given a row and column index in a 2D data list.</p> <p>Parameters:</p> Name Type Description Default <code>row_now</code> <code>int</code> <p>The current row index.</p> required <code>col_now</code> <code>int</code> <p>The current column index.</p> required <code>data_list</code> <code>list</code> <p>A 2D array representing the data converted from raster data.</p> required <code>direction_num</code> <code>int</code> <p>The number of migration directions (default: 4). Only two values, 4 and 8, are allowed; if any other value is entered, it is recognized as the default 4 direction.</p> <code>4</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of neighboring valid coordinates.</p> Source code in <code>geoca/cellularautomata.py</code> <pre><code>def get_neighbors(row_now, col_now, data_list, direction_num=4):\n    \"\"\"\n    Get neighboring valid coordinates given a row and column index in a 2D data list.\n\n    Args:\n        row_now (int): The current row index.\n        col_now (int): The current column index.\n        data_list (list): A 2D array representing the data converted from raster data.\n        direction_num (int): The number of migration directions (default: 4). Only two values, 4 and 8, are allowed; if any other value is entered, it is recognized as the default 4 direction.\n\n    Returns:\n        list: A list of neighboring valid coordinates.\n    \"\"\"\n\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    if direction_num == 8:\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    neighbors = []\n    for dr, dc in directions:\n        new_row, new_col = row_now + dr, col_now + dc\n        if 0 &lt;= new_row &lt; len(data_list) and 0 &lt;= new_col &lt; len(data_list[0]) and data_list[new_row][new_col] is not None:\n            neighbors.append((new_row, new_col))\n    return neighbors\n</code></pre>"},{"location":"cellularautomata/#geoca.cellularautomata.migrate_population_disperse","title":"<code>migrate_population_disperse(data_list, population, direction_num=4, proportion=[0.5, 0.25, 0.15, 0.05])</code>","text":"<p>The population is dispersed and migrates to the neighborhood based on the raster pixel values.</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>list</code> <p>A 2D array converted from a raster of environmental data.</p> required <code>population</code> <code>list</code> <p>A 2D array converted from the initial population count of each pixel.</p> required <code>direction_num</code> <code>int</code> <p>The number of migration directions (default: 4). Only two values, 4 and 8, are allowed; if any other value is entered, it is recognized as the default 4 direction.</p> <code>4</code> <code>proportion</code> <code>list</code> <p>A list of the proportion of the population that migrated to each neighboring pixel, ordered from highest to lowest suitability for migration. The proportion ranges from 0 to 1, with a proportion of 1 for complete migration and 0.5 for 50 percent migration.</p> <code>[0.5, 0.25, 0.15, 0.05]</code> <p>Returns:</p> Type Description <code>list</code> <p>A 2D list representing the new population distribution after migration.</p> Source code in <code>geoca/cellularautomata.py</code> <pre><code>def migrate_population_disperse(data_list, population, direction_num=4, proportion=[0.5, 0.25, 0.15, 0.05]):\n    \"\"\"\n    The population is dispersed and migrates to the neighborhood based on the raster pixel values.\n\n    Args:\n        data_list (list): A 2D array converted from a raster of environmental data.\n        population (list): A 2D array converted from the initial population count of each pixel.\n        direction_num (int): The number of migration directions (default: 4). Only two values, 4 and 8, are allowed; if any other value is entered, it is recognized as the default 4 direction.\n        proportion (list): A list of the proportion of the population that migrated to each neighboring pixel, ordered from highest to lowest suitability for migration. The proportion ranges from 0 to 1, with a proportion of 1 for complete migration and 0.5 for 50 percent migration.\n\n    Returns:\n        list: A 2D list representing the new population distribution after migration.\n    \"\"\"\n    new_population = [[0 for _ in range(len(data_list[0]))] for _ in range(len(data_list))]\n\n    for row in range(len(data_list)):\n        for col in range(len(data_list[0])):\n            if not data_list[row][col]:\n                continue  # Skip invalid regions\n            neighbors = get_neighbors(row, col, data_list, direction_num)\n            if not neighbors:\n                continue  # Skip if no valid neighbors\n\n            # Sort neighbors based on the pixel value, in descending order\n            sorted_neighbors = sorted(neighbors, key=lambda n: data_list[n[0]][n[1]], reverse=True)\n\n            migrated_population = 0\n            if not population[row][col]:\n                continue  # Skip invalid regions\n\n            # Distribute the population based on the given proportions\n            for i in range(min(len(sorted_neighbors), len(proportion)-1)):\n                target_row, target_col = sorted_neighbors[i]\n                distributed_value = population[row][col] * proportion[i]\n                new_population[target_row][target_col] += int(distributed_value)\n                # new_population[target_row][target_col] += int(population[row][col] * proportion[i])\n                migrated_population += new_population[target_row][target_col]\n\n            # Remaining population stays\n            if migrated_population &lt; population[row][col]:\n                new_population[row][col] += population[row][col] - migrated_population\n\n    return new_population\n</code></pre>"},{"location":"cellularautomata/#geoca.cellularautomata.migrate_population_focus","title":"<code>migrate_population_focus(data_list, population, direction_num=4, proportion=1)</code>","text":"<p>The population is focused towards the most suitable nearby migration areas based on the raster pixel values.</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>list</code> <p>A 2D array converted from a raster of environmental data.</p> required <code>population</code> <code>list</code> <p>A 2D array converted from the initial population count of each pixel.</p> required <code>direction_num</code> <code>int</code> <p>The number of migration directions (default: 4). Only two values, 4 and 8, are allowed; if any other value is entered, it is recognized as the default 4 direction.</p> <code>4</code> <code>proportion</code> <code>float</code> <p>The proportion of population to migrate (default: 1). The proportion ranges from 0 to 1, with a proportion of 1 for complete migration and 0.5 for 50 percent migration.</p> <code>1</code> <p>Returns:</p> Type Description <code>list</code> <p>A 2D list representing the new population distribution after migration.</p> Source code in <code>geoca/cellularautomata.py</code> <pre><code>def migrate_population_focus(data_list, population, direction_num=4, proportion=1):\n    \"\"\"\n    The population is focused towards the most suitable nearby migration areas based on the raster pixel values.\n\n    Args:\n        data_list (list): A 2D array converted from a raster of environmental data.\n        population (list): A 2D array converted from the initial population count of each pixel.\n        direction_num (int): The number of migration directions (default: 4). Only two values, 4 and 8, are allowed; if any other value is entered, it is recognized as the default 4 direction.\n        proportion (float): The proportion of population to migrate (default: 1). The proportion ranges from 0 to 1, with a proportion of 1 for complete migration and 0.5 for 50 percent migration.\n\n    Returns:\n        list: A 2D list representing the new population distribution after migration.\n    \"\"\"\n    new_population = [[0 for _ in range(len(data_list[0]))] for _ in range(len(data_list))]\n\n    for row in range(len(data_list)):\n        for col in range(len(data_list[0])):\n            if not data_list[row][col]:\n                continue  # Skip invalid regions\n            neighbors = get_neighbors(row, col, data_list, direction_num)\n            if not neighbors:\n                continue  # Skip if no valid neighbors\n\n            max_value = max([data_list[r][c] for r, c in neighbors])\n            highest_neighbors = [(r, c) for r, c in neighbors if data_list[r][c] == max_value]\n\n            target_row, target_col = random.choice(highest_neighbors)\n\n            if not population[row][col]:\n                continue  # Skip invalid regions\n            migrated_population = int(population[row][col] * proportion)\n\n            new_population[target_row][target_col] += migrated_population\n            new_population[row][col] += population[row][col] - migrated_population\n\n    return new_population\n</code></pre>"},{"location":"cellularautomata/#geoca.cellularautomata.migrate_time","title":"<code>migrate_time(data_list, cost_list)</code>","text":"<p>Calculate the migration time based on the cost path raster and the environment raster.</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>list</code> <p>A 2D array converted from a raster of environmental data.</p> required <code>cost_list</code> <code>list</code> <p>A 2D array converted from the cost path raster.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the cumulative migration time, the number of iterations, and a list of environment raster values corresponding to the cost path raster.</p> Source code in <code>geoca/cellularautomata.py</code> <pre><code>def migrate_time(data_list, cost_list):\n    \"\"\"\n    Calculate the migration time based on the cost path raster and the environment raster.\n\n    Args:\n        data_list (list): A 2D array converted from a raster of environmental data.\n        cost_list (list): A 2D array converted from the cost path raster.\n\n    Returns:\n        tuple: A tuple containing the cumulative migration time, the number of iterations, and a list of environment raster values corresponding to the cost path raster.\n    \"\"\"\n    iteration_count = 0  # Initialize the iteration counter\n    migration_time = 0  # Initialize migration time\n    positions_data_list = []  # Initialize the list of environment raster values corresponding to cost paths\n\n    # In ArcGIS Pro, each least-cost path is assigned a value when encountered in the scanning process.\n    # The ending cell on the original source raster of a cost path receives 1, the first path receives 3.\n\n    # Find initial position (cost path raster pixel value = 1)\n    initial_positions = []\n    for r in range(len(cost_list)):\n        for c in range(len(cost_list[0])):\n            if cost_list[r][c] == 1:\n                initial_positions.append((r, c))\n                positions_data_list.append(data_list[r][c])\n\n    if len(initial_positions) != 1:\n        # Finds more than one or zero initial positions, exits the loop\n        raise RuntimeError(\"Error: The cost path raster should have and only have one initial position.\")\n\n    for initial_row, initial_col in initial_positions:\n        while True:\n            # Get cost path raster coordinates in eight directions around the initial position\n            neighbors = get_neighbors(initial_row, initial_col, cost_list, 8)\n            # Get the elements in the eight coordinates that have a cost path raster pixel value of 3\n            threes = [(r, c) for r, c in neighbors if cost_list[r][c] == 3]\n\n            iteration_count += 1    # Iterative counter accumulation\n\n            # If the threes list has only one value, the program runs normally\n            if len(threes) == 1:\n                # Calculate migration time\n                target_row, target_col = threes[0]\n                migration_diff = data_list[target_row][target_col] - data_list[initial_row][initial_col]\n                migration_time += migration_diff + 30\n\n                # Adding environmental raster values for locations corresponding to cost paths\n                positions_data_list.append(data_list[target_row][target_col])\n\n                # Update cost path list element values so that computed pixels are not subsequently re-read\n                cost_list[target_row][target_col] = 5\n\n                # Update initial position\n                initial_row, initial_col = target_row, target_col\n            if len(threes) == 0:\n                # If no element with value 3 is found, exit the loop\n                print(\"Cost path raster traversal is complete.\")\n                break\n            elif len(threes) &gt; 1:\n                # Finds more than one element with a value of 3 and exits the loop\n                raise RuntimeError(\"Error: multiple cost path raster values exist around the initial position.\")\n\n    return migration_time, iteration_count, positions_data_list\n</code></pre>"},{"location":"cellularautomata/#geoca.cellularautomata.run_iterations_num","title":"<code>run_iterations_num(iterations, data_list, population_num=10, direction_num=4, type_migration='focus', migration_proportion=1)</code>","text":"<p>Running a cellular automata using a uniform initial population count to simulate population migration based on a raster of environmental data.</p> <p>Parameters:</p> Name Type Description Default <code>iterations</code> <code>int</code> <p>The number of iterations to run the simulation.</p> required <code>data_list</code> <code>list</code> <p>A 2D array converted from a raster of environmental data.</p> required <code>population_num</code> <code>int</code> <p>The initial population count at each pixel (default: 10).</p> <code>10</code> <code>direction_num</code> <code>int</code> <p>The number of migration directions (default: 4). Only two values, 4 and 8, are allowed; if any other value is entered, it is recognized as the default 4 direction.</p> <code>4</code> <code>type_migration</code> <code>str</code> <p>The type of migration to use, either \"focus\" or \"disperse\" (default: \"focus\").</p> <code>'focus'</code> <code>migration_proportion</code> <code>float or list</code> <p>The proportion of population to migrate (default: 1). The proportion ranges from 0 to 1, with a proportion of 1 for complete migration and 0.5 for 50 percent migration.</p> <code>1</code> <p>Returns:</p> Type Description <code>list</code> <p>A 2D list representing the population distribution after running the simulation.</p> Source code in <code>geoca/cellularautomata.py</code> <pre><code>def run_iterations_num(iterations, data_list, population_num=10, direction_num=4, type_migration=\"focus\", migration_proportion=1):\n    \"\"\"\n    Running a cellular automata using a uniform initial population count to simulate population migration based on a raster of environmental data.\n\n    Args:\n        iterations (int): The number of iterations to run the simulation.\n        data_list (list): A 2D array converted from a raster of environmental data.\n        population_num (int): The initial population count at each pixel (default: 10).\n        direction_num (int): The number of migration directions (default: 4). Only two values, 4 and 8, are allowed; if any other value is entered, it is recognized as the default 4 direction.\n        type_migration (str): The type of migration to use, either \"focus\" or \"disperse\" (default: \"focus\").\n        migration_proportion (float or list): The proportion of population to migrate (default: 1). The proportion ranges from 0 to 1, with a proportion of 1 for complete migration and 0.5 for 50 percent migration.\n\n    Returns:\n        list: A 2D list representing the population distribution after running the simulation.\n    \"\"\"\n    population = [[population_num for _ in range(len(data_list[0]))] for _ in range(len(data_list))]\n\n    for i in tqdm(range(iterations)):\n        if type_migration == \"focus\":\n            population = migrate_population_focus(data_list, population, direction_num, migration_proportion)\n        elif type_migration == \"disperse\":\n            population = migrate_population_disperse(data_list, population, direction_num, migration_proportion)\n\n    return population\n</code></pre>"},{"location":"cellularautomata/#geoca.cellularautomata.run_iterations_pop","title":"<code>run_iterations_pop(iterations, data_list, population_list, direction_num=4, type_migration='focus', migration_proportion=1)</code>","text":"<p>Running a cellular automata using an initial population size raster to simulate population migration based on a raster of environmental data.</p> <p>Parameters:</p> Name Type Description Default <code>iterations</code> <code>int</code> <p>The number of iterations to run the simulation.</p> required <code>data_list</code> <code>list</code> <p>A 2D array converted from a raster of environmental data.</p> required <code>population_list</code> <code>list</code> <p>A 2D array converted from an initial population size raster.</p> required <code>direction_num</code> <code>int</code> <p>The number of migration directions (default: 4). Only two values, 4 and 8, are allowed; if any other value is entered, it is recognized as the default 4 direction.</p> <code>4</code> <code>type_migration</code> <code>str</code> <p>The type of migration to use, either \"focus\" or \"disperse\" (default: \"focus\").</p> <code>'focus'</code> <code>migration_proportion</code> <code>float or list</code> <p>The proportion of population to migrate (default: 1). The proportion ranges from 0 to 1, with a proportion of 1 for complete migration and 0.5 for 50 percent migration.</p> <code>1</code> <p>Returns:</p> Type Description <code>list</code> <p>A 2D list representing the population distribution after running the simulation.</p> Source code in <code>geoca/cellularautomata.py</code> <pre><code>def run_iterations_pop(iterations, data_list, population_list, direction_num=4, type_migration=\"focus\", migration_proportion=1):\n    \"\"\"\n    Running a cellular automata using an initial population size raster to simulate population migration based on a raster of environmental data.\n\n    Args:\n        iterations (int): The number of iterations to run the simulation.\n        data_list (list): A 2D array converted from a raster of environmental data.\n        population_list (list): A 2D array converted from an initial population size raster.\n        direction_num (int): The number of migration directions (default: 4). Only two values, 4 and 8, are allowed; if any other value is entered, it is recognized as the default 4 direction.\n        type_migration (str): The type of migration to use, either \"focus\" or \"disperse\" (default: \"focus\").\n        migration_proportion (float or list): The proportion of population to migrate (default: 1). The proportion ranges from 0 to 1, with a proportion of 1 for complete migration and 0.5 for 50 percent migration.\n\n    Returns:\n        list: A 2D list representing the population distribution after running the simulation.\n    \"\"\"\n\n    for i in tqdm(range(iterations)):\n        if type_migration == \"focus\":\n            population_list = migrate_population_focus(data_list, population_list, direction_num, migration_proportion)\n        elif type_migration == \"disperse\":\n            population_list = migrate_population_disperse(data_list, population_list, direction_num, migration_proportion)\n\n    return population_list\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<ul> <li>\u7b80\u4f53\u4e2d\u6587</li> </ul>"},{"location":"changelog/#changelog","title":"Changelog","text":""},{"location":"changelog/#v003-2024224","title":"v0.0.3 - 2024.2.24","text":"<p>Improvement:</p> <ul> <li>Remove all code used for initial project testing.</li> </ul> <p>New Features:</p> <ul> <li>Read raster data from a file, convert the data into a Python list.</li> <li>Create a raster template based on the input raster, and replace the data from list into the new raster.</li> <li>Running CA models based on raster data to analyze population and other resource migration.</li> </ul>"},{"location":"changelog/#v004-2024318","title":"v0.0.4 - 2024.3.18","text":"<p>Improvement:</p> <ul> <li>Modify the original code and comments.</li> <li>Add new Features.</li> </ul> <p>New Features:</p> <ul> <li>Reads multiple raster data (.tif) from a folder and stores it in a dictionary.</li> <li>Reorganizes data from a list dictionary representing multiple raster data.</li> </ul>"},{"location":"changelog/#v005-2024329","title":"v0.0.5 - 2024.3.29","text":"<p>Improvement:</p> <ul> <li>Fix some codes for exporting raster data.</li> </ul>"},{"location":"changelog/#v006-202496","title":"v0.0.6 - 2024.9.6","text":"<p>Improvement:</p> <ul> <li>Modify the names of some functions.</li> </ul> <p>New Features:</p> <ul> <li>Running a cellular automata using an initial population size raster.</li> </ul>"},{"location":"changelog/#v007-2024911","title":"v0.0.7 - 2024.9.11","text":"<p>Improvement:</p> <ul> <li>Modify the names of some functions.</li> <li>The direction of migration was reduced from eight to four (only east, west, south and north were retained).</li> </ul> <p>New Features:</p> <ul> <li>The population can be dispersed and migrated to various neighboring areas based on the size of the raster pixel values.</li> <li>A proportion of the population can be focused and migrated to the most suitable areas.</li> </ul>"},{"location":"changelog/#v008-2024912","title":"v0.0.8 - 2024.9.12","text":"<p>Improvement:</p> <ul> <li>Number of migration directions can be set (4 or 8).</li> </ul>"},{"location":"changelog/#v009-2024917","title":"v0.0.9 - 2024.9.17","text":"<p>New Features:</p> <ul> <li>Calculate the migration time based on the cost path raster and the environment raster.</li> </ul>"},{"location":"changelog/#v0010-2024919","title":"v0.0.10 - 2024.9.19","text":"<p>Improvement:</p> <ul> <li>Modify CA model output effect, add progress bar.</li> </ul>"},{"location":"changelog/#v0011-2024920","title":"v0.0.11 - 2024.9.20","text":"<p>Improvement:</p> <ul> <li>Fixed partial function modeling algorithm.</li> </ul>"},{"location":"changelog.zh/","title":"Changelog.zh","text":"<ul> <li>English</li> </ul>"},{"location":"changelog.zh/#_1","title":"\u7248\u672c\u66f4\u65b0\u65e5\u5fd7","text":""},{"location":"changelog.zh/#v003-2024224","title":"v0.0.3 - 2024.2.24","text":"<p>\u6539\u8fdb\uff1a</p> <ul> <li>\u5220\u9664\u7528\u4e8e\u521d\u59cb\u9879\u76ee\u6d4b\u8bd5\u7684\u6240\u6709\u4ee3\u7801\u3002</li> </ul> <p>\u65b0\u529f\u80fd\uff1a</p> <ul> <li>\u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u6805\u683c\u6570\u636e\uff0c\u5e76\u5c06\u6570\u636e\u8f6c\u6362\u4e3a Python \u5217\u8868\u3002</li> <li>\u6839\u636e\u8f93\u5165\u6805\u683c\u521b\u5efa\u6805\u683c\u6a21\u677f\uff0c\u5e76\u5c06\u5217\u8868\u4e2d\u7684\u6570\u636e\u66ff\u6362\u5230\u8be5\u6805\u683c\u6a21\u677f\u4e2d\u3002</li> <li>\u6839\u636e\u6805\u683c\u6570\u636e\u8fd0\u884c CA \u6a21\u578b\uff0c\u5206\u6790\u4eba\u53e3\u6216\u5176\u4ed6\u8d44\u6e90\u7684\u8fc1\u79fb\u60c5\u51b5\u3002</li> </ul>"},{"location":"changelog.zh/#v004-2024318","title":"v0.0.4 - 2024.3.18","text":"<p>\u6539\u8fdb\uff1a</p> <ul> <li>\u4fee\u6539\u539f\u59cb\u4ee3\u7801\u548c\u6ce8\u91ca\u3002</li> <li>\u6dfb\u52a0\u90e8\u5206\u65b0\u529f\u80fd\u3002</li> </ul> <p>\u65b0\u529f\u80fd\uff1a</p> <ul> <li>\u4ece\u6587\u4ef6\u5939\u4e2d\u6279\u91cf\u8bfb\u53d6\u6805\u683c\u6570\u636e\uff08.tif\uff09\u5e76\u5c06\u5176\u5b58\u50a8\u5728\u5b57\u5178\u4e2d\u3002</li> <li>\u5bf9\u4ee3\u8868\u591a\u4e2a\u6805\u683c\u6570\u636e\u7684\u5217\u8868\u5b57\u5178\u8fdb\u884c\u91cd\u6784\u3002</li> </ul>"},{"location":"changelog.zh/#v005-2024329","title":"v0.0.5 - 2024.3.29","text":"<p>\u6539\u8fdb\uff1a</p> <ul> <li>\u4fee\u590d\u5bfc\u51fa\u6805\u683c\u6570\u636e\u90e8\u5206\u7684\u76f8\u5173\u4ee3\u7801\u3002</li> </ul>"},{"location":"changelog.zh/#v006-202496","title":"v0.0.6 - 2024.9.6","text":"<p>\u6539\u8fdb:</p> <ul> <li>\u4fee\u6539\u90e8\u5206\u51fd\u6570\u540d\u79f0\u3002</li> </ul> <p>\u65b0\u529f\u80fd:</p> <ul> <li>\u901a\u8fc7\u521d\u59cb\u4eba\u53e3\u6570\u91cf\u6805\u683c\u6267\u884c\u5143\u80de\u81ea\u52a8\u673a\u3002</li> </ul>"},{"location":"changelog.zh/#v007-2024911","title":"v0.0.7 - 2024.9.11","text":"<p>\u6539\u8fdb:</p> <ul> <li>\u4fee\u6539\u90e8\u5206\u51fd\u6570\u540d\u79f0\u3002</li> <li>\u8fc1\u79fb\u65b9\u5411\u75318\u4e2a\u964d\u4e3a4\u4e2a\uff08\u4ec5\u4fdd\u7559\u4e1c\u3001\u897f\u3001\u5357\u3001\u5317\uff09\u3002</li> </ul> <p>\u65b0\u529f\u80fd:</p> <ul> <li>\u4eba\u53e3\u53ef\u57fa\u4e8e\u6805\u683c\u50cf\u5143\u503c\u5927\u5c0f\u5206\u6563\u8fc1\u79fb\u81f3\u5404\u4e2a\u76f8\u90bb\u533a\u57df\u3002</li> <li>\u53ef\u5c06\u4e00\u5b9a\u6bd4\u4f8b\u7684\u4eba\u53e3\u96c6\u4e2d\u8fc1\u79fb\u5230\u9002\u5b9c\u6027\u6700\u5f3a\u7684\u5730\u533a\u3002</li> </ul>"},{"location":"changelog.zh/#v008-2024912","title":"v0.0.8 - 2024.9.12","text":"<p>\u6539\u8fdb:</p> <ul> <li>\u53ef\u8bbe\u7f6e\u8fc1\u79fb\u65b9\u5411\u7684\u6570\u91cf\uff084 \u6216 8\uff09\u3002</li> </ul>"},{"location":"changelog.zh/#v009-2024917","title":"v0.0.9 - 2024.9.17","text":"<p>\u65b0\u529f\u80fd:</p> <ul> <li>\u6839\u636e\u6210\u672c\u8def\u5f84\u6805\u683c\u53ca\u73af\u5883\u6805\u683c\u8ba1\u7b97\u8fc1\u79fb\u65f6\u95f4\u3002</li> </ul>"},{"location":"changelog.zh/#v0010-2024919","title":"v0.0.10 - 2024.9.19","text":"<p>\u6539\u8fdb:</p> <ul> <li>\u4fee\u6539CA\u6a21\u578b\u8f93\u51fa\u6548\u679c\uff0c\u6dfb\u52a0\u8fdb\u5ea6\u6761\u3002</li> </ul>"},{"location":"changelog.zh/#v0011-2024920","title":"v0.0.11 - 2024.9.20","text":"<p>\u6539\u8fdb:</p> <ul> <li>\u4fee\u6b63\u90e8\u5206\u51fd\u6570\u6a21\u578b\u7b97\u6cd5\u3002</li> </ul>"},{"location":"contributing/","title":"Contributing (English)","text":"<ul> <li>\u7b80\u4f53\u4e2d\u6587: \u6b64\u9875\u9762\u672a\u7ffb\u8bd1\u4e3a\u7b80\u4f53\u4e2d\u6587\u3002</li> </ul>"},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/Haorui-Jiang/geoca/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>geoca could always use more documentation, whether as part of the official geoca docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/Haorui-Jiang/geoca/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up geoca for local development.</p> <ol> <li> <p>Fork the geoca repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/geoca.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv geoca\n$ cd geoca/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 geoca tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/Haorui-Jiang/geoca/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":"<ul> <li>\u7b80\u4f53\u4e2d\u6587: \u6b64\u9875\u9762\u672a\u7ffb\u8bd1\u4e3a\u7b80\u4f53\u4e2d\u6587\u3002</li> </ul>"},{"location":"faq/#faq","title":"FAQ","text":""},{"location":"index.zh/","title":"Index.zh","text":"<ul> <li>English</li> </ul>"},{"location":"index.zh/#geoca","title":"geoca \u4ecb\u7ecd","text":"<p>\u57fa\u4e8e\u5730\u7406\u6805\u683c\u6570\u636e\u7684 CA \u6a21\u578b Python \u6a21\u5757</p> <ul> <li>\u5f00\u6e90\u8bb8\u53ef\u8bc1\uff1aMIT License</li> <li>\u6587\u6863\u7f51\u7ad9\uff1ahttps://Haorui-Jiang.github.io/geoca</li> </ul>"},{"location":"index.zh/#_1","title":"\u4e3b\u8981\u529f\u80fd","text":"<ul> <li>\u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u6805\u683c\u6570\u636e\uff0c\u5e76\u5c06\u6570\u636e\u8f6c\u6362\u6210 Python \u5217\u8868\u7b49\u683c\u5f0f\u3002</li> <li>\u6839\u636e\u8f93\u5165\u7684\u6805\u683c\u6570\u636e\u521b\u5efa\u6805\u683c\u6a21\u677f\uff0c\u5e76\u5c06\u6570\u636e\u7edf\u4e00\u66ff\u6362\u5230\u8be5\u6805\u683c\u6a21\u677f\u7684\u5bf9\u5e94\u4f4d\u7f6e\u3002</li> <li>\u6839\u636e\u6805\u683c\u6570\u636e\u8fd0\u884c CA \u6a21\u578b\uff0c\u5206\u6790\u4eba\u53e3\u6216\u5176\u4ed6\u8d44\u6e90\u7684\u8fc1\u79fb\u60c5\u51b5\u3002</li> </ul>"},{"location":"installation/","title":"Installation (English)","text":"<ul> <li>\u7b80\u4f53\u4e2d\u6587: \u6b64\u9875\u9762\u672a\u7ffb\u8bd1\u4e3a\u7b80\u4f53\u4e2d\u6587\u3002</li> </ul>"},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install geoca, run this command in your terminal:</p> <pre><code>pip install geoca\n</code></pre> <p>This is the preferred method to install geoca, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install geoca from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/Haorui-Jiang/geoca\n</code></pre>"},{"location":"rasterconvert/","title":"rasterconvert module","text":"<ul> <li>\u7b80\u4f53\u4e2d\u6587: \u6b64\u9875\u9762\u672a\u7ffb\u8bd1\u4e3a\u7b80\u4f53\u4e2d\u6587\u3002</li> </ul>"},{"location":"rasterconvert/#rasterconvert-module","title":"rasterconvert module","text":"<p>The RasterConverter module provides a set of functions for efficient data conversion and manipulation of raster datasets.</p>"},{"location":"rasterconvert/#geoca.rasterconvert.multiRaster_listDict","title":"<code>multiRaster_listDict(folder_path, index_list)</code>","text":"<p>Reads multiple raster data (.tif) from a folder and stores it in a dictionary based on specific index values.</p> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <code>str</code> <p>The path to the folder containing raster data (.tif).</p> required <code>index_list</code> <code>list</code> <p>A list of indices corresponding to the raster files.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with a specific index value as the key and a list of stored raster pixel values as the value.</p> Source code in <code>geoca/rasterconvert.py</code> <pre><code>def multiRaster_listDict(folder_path, index_list):\n    \"\"\"\n    Reads multiple raster data (.tif) from a folder and stores it in a dictionary based on specific index values.\n\n    Args:\n        folder_path (str): The path to the folder containing raster data (.tif).\n        index_list (list): A list of indices corresponding to the raster files.\n\n    Returns:\n        dict: A dictionary with a specific index value as the key and a list of stored raster pixel values as the value.\n    \"\"\"\n    # Create a list of .tif files in the specified folder\n    tif_list = list()\n    for file in os.listdir(folder_path):\n        if file[-4:] == \".tif\":\n            tif_list.append(file)\n\n    # Check that the raster file list is the same length as the index list\n    if len(tif_list) != len(index_list):\n        raise Exception(\"The length of the raster file list does not match the index list..\")\n\n    print(\"Data reading...\")\n    # Create a data dictionary with keys as index values for the corresponding positions in the index list and values as the data list generated by the raster file conversion.\n    data_dict = dict()\n    for i in tqdm(range(len(tif_list))):\n        index, tif = index_list[i], tif_list[i]\n        tif_path = os.path.join(folder_path, tif)\n        data_dict[index] = raster_list(tif_path)\n    print(\"Data reading is complete!\")\n\n    return data_dict\n</code></pre>"},{"location":"rasterconvert/#geoca.rasterconvert.process_raster_data","title":"<code>process_raster_data(input_raster_path, output_raster_path, new_data, nodata_value)</code>","text":"<p>Create a single-band raster template based on the input raster, process the raster data by replacing pixel values with the new data.</p> <p>Parameters:</p> Name Type Description Default <code>input_raster_path</code> <code>str</code> <p>Path to the original raster file.</p> required <code>output_raster_path</code> <code>str</code> <p>Path to save the output raster file.</p> required <code>new_data</code> <code>list</code> <p>New data in the form of a 2D list.</p> required <code>nodata_value</code> <code>num</code> <p>NoData value in new_data.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>geoca/rasterconvert.py</code> <pre><code>def process_raster_data(input_raster_path, output_raster_path, new_data, nodata_value):\n    \"\"\"\n    Create a single-band raster template based on the input raster, process the raster data by replacing pixel values with the new data.\n\n    Args:\n        input_raster_path (str): Path to the original raster file.\n        output_raster_path (str): Path to save the output raster file.\n        new_data (list): New data in the form of a 2D list.\n        nodata_value (num): NoData value in new_data.\n\n    Returns:\n        None\n    \"\"\"\n    # Open the original raster dataset\n    input_raster = rasterio.open(input_raster_path)\n\n    # Set the NoData parameter of the output raster\n    nodata_raster = input_raster.nodata\n    # If nodata_value is not None, set the nodata_raster to the value of nodata_value\n    if nodata_value is not None:\n        nodata_raster = nodata_value\n\n    # Create a new raster from the original raster dataset\n    output_raster = rasterio.open(output_raster_path, \"w\", driver=\"GTiff\",\n                                  height=input_raster.height, width=input_raster.width, count=1,\n                                  dtype=input_raster.dtypes[0], crs=input_raster.crs, transform=input_raster.transform,\n                                  nodata=nodata_raster)\n\n    # Replace pixel values with new data\uff0cand set the NoData value\n    masked_array = new_data == nodata_value\n    output_raster.write(np.array(new_data), 1, masked=masked_array)\n\n    print(f\"Processed raster data saved to {output_raster_path}.\")\n\n    # Close datasets\n    input_raster.close()\n    output_raster.close()\n</code></pre>"},{"location":"rasterconvert/#geoca.rasterconvert.raster_list","title":"<code>raster_list(file_path)</code>","text":"<p>Read raster data from a file, convert NoData values to None, and convert the data into a Python list.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the raster file.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Raster data as a Python list with NoData values converted to None.</p> Source code in <code>geoca/rasterconvert.py</code> <pre><code>def raster_list(file_path):\n    \"\"\"\n    Read raster data from a file, convert NoData values to None, and convert the data into a Python list.\n\n    Args:\n        file_path (str): Path to the raster file.\n\n    Returns:\n        list: Raster data as a Python list with NoData values converted to None.\n    \"\"\"\n    # Open the raster file\n    dataset = rasterio.open(file_path)\n\n    # Check if the dataset was opened successfully\n    if dataset is None:\n        raise Exception(\"Failed to open the raster file.\")\n\n    # Get the raster band\n    band = dataset.read(1)\n\n    # Get the NoData value\n    nodata_value = dataset.nodata\n\n    # Get the number of rows and columns of raster data\n    rows, cols = band.shape\n\n    # Convert raster data to matrix\n    raster_matrix = band.reshape(rows, cols)\n\n    # Converts data types to object types to support storing None\n    raster_matrix = raster_matrix.astype(object)\n\n    # Convert NoData values to None\n    raster_matrix[raster_matrix == nodata_value] = None\n\n    # Convert NumPy array to a Python list\n    raster_list = [[raster_matrix[row][col] for col in range(cols)] for row in range(rows)]\n\n    return raster_list\n</code></pre>"},{"location":"rasterconvert/#geoca.rasterconvert.reorganize_multiRaster_listDict","title":"<code>reorganize_multiRaster_listDict(data_dict, index_list)</code>","text":"<p>Reorganizes data from a list dictionary representing multiple raster data on the basis of the multiRaster_listDict function.</p> <p>Parameters:</p> Name Type Description Default <code>data_dict</code> <code>dict</code> <p>Resulting dictionary file generated by multiRaster_listDict function.</p> required <code>index_list</code> <code>list</code> <p>A list of indexes corresponding to the list of keys of the dictionary file in a defined order,                the same as the index_list parameter of the multiRaster_listDict function.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>The first parameter is a two-dimensional indexed list with the same number of rows and columns as the original        raster data, and the list element values are tuples of horizontal and vertical coordinates. The second parameter        is a data dictionary with the key being the coordinate tuple (index list element value) and the value being a list        of all raster image element values corresponding to the coordinates (in index_list order).</p> Source code in <code>geoca/rasterconvert.py</code> <pre><code>def reorganize_multiRaster_listDict(data_dict, index_list):\n    \"\"\"\n    Reorganizes data from a list dictionary representing multiple raster data on the basis of the multiRaster_listDict function.\n\n    Args:\n        data_dict (dict): Resulting dictionary file generated by multiRaster_listDict function.\n        index_list (list): A list of indexes corresponding to the list of keys of the dictionary file in a defined order,\n                           the same as the index_list parameter of the multiRaster_listDict function.\n\n    Returns:\n        tuple: The first parameter is a two-dimensional indexed list with the same number of rows and columns as the original\n               raster data, and the list element values are tuples of horizontal and vertical coordinates. The second parameter\n               is a data dictionary with the key being the coordinate tuple (index list element value) and the value being a list\n               of all raster image element values corresponding to the coordinates (in index_list order).\n    \"\"\"\n    key1 = list(data_dict.keys())[0]\n    list1 = data_dict[key1]\n    rows, cols = len(list1), len(list1[0])\n\n    data_index_list, data_value_dict = list(), dict()\n    print(\"Data conversion...\")\n    for i in tqdm(range(rows)):\n        inner_list = list()\n        for j in range(cols):\n            row, col = i + 1, j + 1\n            inner_list.append((row, col))\n\n            value_list = list()\n            for index in index_list:\n                data_list = data_dict[index]\n                value_list.append(data_list[i][j])\n            data_value_dict[(row, col)] = value_list\n\n        data_index_list.append(inner_list)\n    print(\"Data conversion is complete!\")\n\n    return data_index_list, data_value_dict\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<ul> <li>\u7b80\u4f53\u4e2d\u6587: \u6b64\u9875\u9762\u672a\u7ffb\u8bd1\u4e3a\u7b80\u4f53\u4e2d\u6587\u3002</li> </ul>"},{"location":"usage/#usage","title":"Usage","text":"<p>To use geoca in a project:</p> <pre><code>import geoca\n</code></pre>"},{"location":"examples/01_CA/","title":"01 CA","text":"<p>Uncomment the following line to install geoca if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geoca\n</pre> # !pip install geoca <p>Import two modules, rasterconvert and cellularautomata.</p> <p>Use rasterconvert for converting raster data formats and cellularautomata for running CA models.</p> In\u00a0[\u00a0]: Copied! <pre>from geoca import rasterconvert, cellularautomata\n</pre> from geoca import rasterconvert, cellularautomata <p>rasterconvert.raster_list(file_path):</p> <ul> <li>Reads raster data from a file and converts the data to a Python list where the NoData value is converted to None.</li> </ul> In\u00a0[\u00a0]: Copied! <pre>raster_file = \"Data/raster.tif\"\ndata_list = rasterconvert.raster_list(raster_file)\n\n# Read the first 100 rows of a data list and output all non-None values\nfor row in data_list[:100]:\n    non_none_values = [value for value in row if value is not None]\n    if non_none_values:\n        print(non_none_values)\n</pre> raster_file = \"Data/raster.tif\" data_list = rasterconvert.raster_list(raster_file)  # Read the first 100 rows of a data list and output all non-None values for row in data_list[:100]:     non_none_values = [value for value in row if value is not None]     if non_none_values:         print(non_none_values) In\u00a0[\u00a0]: Copied! <pre># Set the file paths for the original raster data and the new raster data to be output\ninput_raster_path = raster_file\noutput_raster_path = \"Data/result.tif\"\n</pre> # Set the file paths for the original raster data and the new raster data to be output input_raster_path = raster_file output_raster_path = \"Data/result.tif\" <p>cellularautomata.migrate_population_focus(data_list, population, direction_num=4, proportion=1):</p> <ul> <li>The population is focused towards the most suitable nearby migration areas based on the raster pixel values.</li> </ul> <p>cellularautomata.migrate_population_disperse(data_list, population, direction_num=4, proportion=[0.5, 0.25, 0.15, 0.05]):</p> <ul> <li>The population is dispersed and migrates to the neighborhood based on the raster pixel values.</li> </ul> <p>rasterconvert.process_raster_data(input_raster_path, output_raster_path, new_data, nodata_value):</p> <ul> <li>Create a raster template based on the input raster, process the raster data by replacing pixel values with the new data.</li> </ul> <p>The migrate_population_focus() or migrate_population_disperse() function can be used when exporting raster data after completing some specific rounds of iterations.</p> <p>Note: When using the migrate_population_disperse() function, it is not recommended to iterate too many times as the population migrates to multiple neighboring locations, which may result in an overly dispersed population.</p> In\u00a0[\u00a0]: Copied! <pre># Run the CA model for a specific number of iterations with an initial population size of 10 per pixel\n\n# Create a list of regional populations of the same size as the raster data list and uniformly set all list elements to a value of 10, representing the initial population size of each raster pixel\npopulation = [[10 for _ in range(len(data_list[0]))] for _ in range(len(data_list))]\n\niterations = 20  # Set the number of iterations\n\nfor i in range(iterations):\n    # Migration of 60% of the population to the most suitable nearby raster pixel.\n    population = cellularautomata.migrate_population_focus(data_list, population, 4, 0.6)\n\n    # The suitability of the neighboring raster pixels is sorted,\n    # with 1/2 of the population moving in the direction of the maximum,\n    # 1/4 of the population moving in the second largest direction,\n    # 1/8 of the population moving in the third largest direction,\n    # and the rest of the population remaining where they are.\n    population = cellularautomata.migrate_population_disperse(data_list, population, 4, [0.5, 0.25, 0.125, 0])\n    print(f\"Iteration {i + 1} is complete.\")\n\n    # When the number of iterations is a multiple of 10, output the iteration results as raster data\n    if (i + 1) % 10 == 0:\n        # After process_raster_data() finishes running, the NoData value is 0\n        rasterconvert.process_raster_data(input_raster_path, f\"Data/iterations_{i + 1}.tif\", population, 0)\n</pre> # Run the CA model for a specific number of iterations with an initial population size of 10 per pixel  # Create a list of regional populations of the same size as the raster data list and uniformly set all list elements to a value of 10, representing the initial population size of each raster pixel population = [[10 for _ in range(len(data_list[0]))] for _ in range(len(data_list))]  iterations = 20  # Set the number of iterations  for i in range(iterations):     # Migration of 60% of the population to the most suitable nearby raster pixel.     population = cellularautomata.migrate_population_focus(data_list, population, 4, 0.6)      # The suitability of the neighboring raster pixels is sorted,     # with 1/2 of the population moving in the direction of the maximum,     # 1/4 of the population moving in the second largest direction,     # 1/8 of the population moving in the third largest direction,     # and the rest of the population remaining where they are.     population = cellularautomata.migrate_population_disperse(data_list, population, 4, [0.5, 0.25, 0.125, 0])     print(f\"Iteration {i + 1} is complete.\")      # When the number of iterations is a multiple of 10, output the iteration results as raster data     if (i + 1) % 10 == 0:         # After process_raster_data() finishes running, the NoData value is 0         rasterconvert.process_raster_data(input_raster_path, f\"Data/iterations_{i + 1}.tif\", population, 0) <p>To export raster data after all iterations have been completed, use the run_iterations_num() function or the run_iterations_pop() function.</p> <p>cellularautomata.run_iterations_num(iterations, data_list, population_num=10, direction_num=4, type_migration=\"focus\", migration_proportion=1):</p> <ul> <li>Running a cellular automata using a uniform initial population count to simulate population migration based on a raster of environmental data.</li> </ul> In\u00a0[\u00a0]: Copied! <pre># Run the cellular automata simulation for 5 iterations with an initial population count of 10 at each pixel\nnew_data = cellularautomata.run_iterations_num(5, data_list, population_num=10)\n\nrasterconvert.process_raster_data(input_raster_path, output_raster_path, new_data, 0)\n</pre> # Run the cellular automata simulation for 5 iterations with an initial population count of 10 at each pixel new_data = cellularautomata.run_iterations_num(5, data_list, population_num=10)  rasterconvert.process_raster_data(input_raster_path, output_raster_path, new_data, 0) <p>cellularautomata.run_iterations_pop(iterations, data_list, population_list, direction_num=4, type_migration=\"focus\", migration_proportion=1):</p> <ul> <li>Running a cellular automata using an initial population size raster to simulate population migration based on a raster of environmental data.</li> </ul> In\u00a0[\u00a0]: Copied! <pre>population_file = \"Data/population.tif\"\npopulation_list = rasterconvert.raster_list(population_file)\n\n# Run the cellular automata simulation for 5 iterations, with the initial population size of each pixel determined from a list of population raster values\nnew_data = cellularautomata.run_iterations_pop(5, data_list, population_list)\n\nrasterconvert.process_raster_data(input_raster_path, output_raster_path, new_data, 0)\n</pre> population_file = \"Data/population.tif\" population_list = rasterconvert.raster_list(population_file)  # Run the cellular automata simulation for 5 iterations, with the initial population size of each pixel determined from a list of population raster values new_data = cellularautomata.run_iterations_pop(5, data_list, population_list)  rasterconvert.process_raster_data(input_raster_path, output_raster_path, new_data, 0) <p>cellularautomata.migrate_time(data_list, cost_list):</p> <ul> <li>Calculate the migration time based on the cost path raster and the environment raster.</li> </ul> In\u00a0[\u00a0]: Copied! <pre>cost_file = \"Data/CostPath.tif\"\ncost_list = rasterconvert.raster_list(cost_file)\n\n# Output the migration time, number of iterations,\n# and a list of environmental raster values corresponding to the cost paths\ntime, count, costData_list = cellularautomata.migrate_time(data_list, cost_list)\nprint(time, count)\nprint(costData_list, len(costData_list))\n</pre> cost_file = \"Data/CostPath.tif\" cost_list = rasterconvert.raster_list(cost_file)  # Output the migration time, number of iterations, # and a list of environmental raster values corresponding to the cost paths time, count, costData_list = cellularautomata.migrate_time(data_list, cost_list) print(time, count) print(costData_list, len(costData_list))"},{"location":"examples/01_CA.zh/","title":"01 CA.zh (\u7b80\u4f53\u4e2d\u6587)","text":"<p>\u5982\u6709\u9700\u8981\uff0c\u8bf7\u53d6\u6d88\u4e0b\u884c\u6ce8\u91ca\u4ee5\u5b89\u88c5 geoca\u3002</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geoca\n</pre> # !pip install geoca <p>\u5bfc\u5165\u4e24\u4e2a\u6a21\u5757\uff1arasterconvert \u548c cellularautomata\u3002</p> <p>\u57fa\u4e8e rasterconvert \u8fdb\u884c\u6805\u683c\u6570\u636e\u683c\u5f0f\u8f6c\u6362\uff0c\u4f7f\u7528 cellularautomata \u8fd0\u884c CA \u6a21\u578b\u3002</p> In\u00a0[\u00a0]: Copied! <pre>from geoca import rasterconvert, cellularautomata\n</pre> from geoca import rasterconvert, cellularautomata <p>rasterconvert.raster_list(file_path)\uff1a</p> <ul> <li>\u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u6805\u683c\u6570\u636e\uff0c\u5e76\u5c06\u6570\u636e\u8f6c\u6362\u4e3a Python \u5217\u8868\uff0c\u5176\u4e2d NoData \u503c\u88ab\u8f6c\u6362\u4e3a None\u3002</li> </ul> In\u00a0[\u00a0]: Copied! <pre>raster_file = \"Data/raster.tif\"\ndata_list = rasterconvert.raster_list(raster_file)\n\n# \u8bfb\u53d6\u6570\u636e\u5217\u8868\u7684\u524d 100 \u884c\uff0c\u5e76\u8f93\u51fa\u6240\u6709\u975e\u7a7a\u503c\nfor row in data_list[:100]:\n    non_none_values = [value for value in row if value is not None]\n    if non_none_values:\n        print(non_none_values)\n</pre> raster_file = \"Data/raster.tif\" data_list = rasterconvert.raster_list(raster_file)  # \u8bfb\u53d6\u6570\u636e\u5217\u8868\u7684\u524d 100 \u884c\uff0c\u5e76\u8f93\u51fa\u6240\u6709\u975e\u7a7a\u503c for row in data_list[:100]:     non_none_values = [value for value in row if value is not None]     if non_none_values:         print(non_none_values) In\u00a0[\u00a0]: Copied! <pre># \u8bbe\u7f6e\u539f\u59cb\u6805\u683c\u6570\u636e\u4ee5\u53ca\u5c06\u8981\u8f93\u51fa\u7684\u65b0\u6805\u683c\u6570\u636e\u6587\u4ef6\u8def\u5f84\ninput_raster_path = raster_file\noutput_raster_path = \"Data/result.tif\"\n</pre> # \u8bbe\u7f6e\u539f\u59cb\u6805\u683c\u6570\u636e\u4ee5\u53ca\u5c06\u8981\u8f93\u51fa\u7684\u65b0\u6805\u683c\u6570\u636e\u6587\u4ef6\u8def\u5f84 input_raster_path = raster_file output_raster_path = \"Data/result.tif\" <p>cellularautomata.migrate_population_focus(data_list, population, direction_num=4, proportion=1)\uff1a</p> <ul> <li>\u6839\u636e\u6805\u683c\u50cf\u5143\u503c\uff0c\u5c06\u4eba\u53e3\u96c6\u4e2d\u8fc1\u79fb\u81f3\u9644\u8fd1\u9002\u5b9c\u6027\u6700\u5f3a\u7684\u533a\u57df\u3002</li> </ul> <p>cellularautomata.migrate_population_disperse(data_list, population, direction_num=4, proportion=[0.5, 0.25, 0.15, 0.05])\uff1a</p> <ul> <li>\u6839\u636e\u6805\u683c\u50cf\u7d20\u503c\uff0c\u4eba\u53e3\u5c06 \u5206\u6563 \u8fc1\u79fb\u5230\u5404\u4e2a\u90bb\u8fd1\u533a\u57df\u3002</li> </ul> <p>rasterconvert.process_raster_data(input_raster_path, output_raster_path, new_data, nodata_value)\uff1a</p> <ul> <li>\u6839\u636e\u8f93\u5165\u6805\u683c\u521b\u5efa\u6805\u683c\u6a21\u677f\uff0c\u5e76\u7528\u65b0\u6570\u636e\u66ff\u6362\u50cf\u7d20\u503c\u6765\u5904\u7406\u6805\u683c\u6570\u636e\u3002</li> </ul> <p>\u5982\u9700\u5728\u5b8c\u6210\u67d0\u4e9b\u7279\u5b9a\u8f6e\u6b21\u7684\u8fed\u4ee3\u540e\u5bfc\u51fa\u6805\u683c\u6570\u636e\u65f6\uff0c\u53ef\u4f7f\u7528 migrate_population_focus() \u6216 migrate_population_disperse() \u51fd\u6570\u3002</p> <p>\u6ce8\u610f\uff1a \u5f53\u4f7f\u7528 migrate_population_disperse() \u51fd\u6570\u65f6\uff0c\u7531\u4e8e\u4eba\u53e3\u5411\u591a\u4e2a\u90bb\u8fd1\u4f4d\u7f6e\u8fc1\u79fb\uff0c\u56e0\u6b64\u4e0d\u5efa\u8bae\u8fed\u4ee3\u6b21\u6570\u8fc7\u591a\uff0c\u5426\u5219\u53ef\u80fd\u4f1a\u5bfc\u81f4\u4eba\u53e3\u8fc7\u5ea6\u5206\u6563\u3002</p> In\u00a0[\u00a0]: Copied! <pre># \u8bbe\u7f6e\u6bcf\u4e2a\u50cf\u5143\u7684\u521d\u59cb\u79cd\u7fa4\u6570\u91cf\u4e3a 10\uff0c\u8fd0\u884c CA \u6a21\u578b\u8fdb\u884c\u7279\u5b9a\u6b21\u6570\u8fed\u4ee3\n\n# \u521b\u5efa\u4e0e\u6805\u683c\u6570\u636e\u5217\u8868\u5927\u5c0f\u76f8\u540c\u7684\u533a\u57df\u4eba\u53e3\u5217\u8868\uff0c\u5e76\u5c06\u6240\u6709\u5217\u8868\u5143\u7d20\u7edf\u4e00\u8bbe\u7f6e\u4e3a 10\uff0c\u4ee3\u8868\u6bcf\u4e2a\u6805\u683c\u50cf\u5143\u7684\u521d\u59cb\u4eba\u53e3\u89c4\u6a21\npopulation = [[10 for _ in range(len(data_list[0]))] for _ in range(len(data_list))]\n\niterations = 20  # \u8bbe\u7f6e\u8fed\u4ee3\u6b21\u6570\n\nfor i in range(iterations):\n    # \u8fc1\u79fb 60% \u7684\u4eba\u53e3\u5230\u9644\u8fd1\u9002\u5b9c\u6027\u6700\u9ad8\u7684\u6805\u683c\u50cf\u5143\n    population = cellularautomata.migrate_population_focus(data_list, population, 4, 0.6)\n\n    # \u5bf9\u76f8\u90bb\u7684\u6805\u683c\u50cf\u5143\u9002\u5b9c\u6027\u8fdb\u884c\u6392\u5e8f\uff0c1/2 \u4eba\u53e3\u5411\u6700\u5927\u503c\u65b9\u5411\u79fb\u52a8\uff0c1/4 \u4eba\u53e3\u5411\u7b2c\u4e8c\u5927\u65b9\u5411\u79fb\u52a8\uff0c1/8 \u4eba\u53e3\u5411\u7b2c\u4e09\u5927\u65b9\u5411\u79fb\u52a8\uff0c\u5176\u4f59\u4eba\u53e3\u7559\u5728\u539f\u5730\n    population = cellularautomata.migrate_population_disperse(data_list, population, 4, [0.5, 0.25, 0.125, 0])\n    print(f\"Iteration {i + 1} is complete.\")\n\n    # \u5f53\u8fed\u4ee3\u6b21\u6570\u662f 10 \u7684\u500d\u6570\u65f6\uff0c\u5c06\u8fed\u4ee3\u7ed3\u679c\u8f93\u51fa\u4e3a\u6805\u683c\u6570\u636e\n    if (i + 1) % 10 == 0:\n        # process_raster_data() \u8fd0\u884c\u7ed3\u675f\u540e\uff0c\u8f93\u51fa\u6805\u683c\u7684 NoData \u503c\u4e3a population \u5217\u8868\u4e2d\u7684 0\n        rasterconvert.process_raster_data(input_raster_path, f\"Data/iterations_{i + 1}.tif\", population, 0)\n</pre> # \u8bbe\u7f6e\u6bcf\u4e2a\u50cf\u5143\u7684\u521d\u59cb\u79cd\u7fa4\u6570\u91cf\u4e3a 10\uff0c\u8fd0\u884c CA \u6a21\u578b\u8fdb\u884c\u7279\u5b9a\u6b21\u6570\u8fed\u4ee3  # \u521b\u5efa\u4e0e\u6805\u683c\u6570\u636e\u5217\u8868\u5927\u5c0f\u76f8\u540c\u7684\u533a\u57df\u4eba\u53e3\u5217\u8868\uff0c\u5e76\u5c06\u6240\u6709\u5217\u8868\u5143\u7d20\u7edf\u4e00\u8bbe\u7f6e\u4e3a 10\uff0c\u4ee3\u8868\u6bcf\u4e2a\u6805\u683c\u50cf\u5143\u7684\u521d\u59cb\u4eba\u53e3\u89c4\u6a21 population = [[10 for _ in range(len(data_list[0]))] for _ in range(len(data_list))]  iterations = 20  # \u8bbe\u7f6e\u8fed\u4ee3\u6b21\u6570  for i in range(iterations):     # \u8fc1\u79fb 60% \u7684\u4eba\u53e3\u5230\u9644\u8fd1\u9002\u5b9c\u6027\u6700\u9ad8\u7684\u6805\u683c\u50cf\u5143     population = cellularautomata.migrate_population_focus(data_list, population, 4, 0.6)      # \u5bf9\u76f8\u90bb\u7684\u6805\u683c\u50cf\u5143\u9002\u5b9c\u6027\u8fdb\u884c\u6392\u5e8f\uff0c1/2 \u4eba\u53e3\u5411\u6700\u5927\u503c\u65b9\u5411\u79fb\u52a8\uff0c1/4 \u4eba\u53e3\u5411\u7b2c\u4e8c\u5927\u65b9\u5411\u79fb\u52a8\uff0c1/8 \u4eba\u53e3\u5411\u7b2c\u4e09\u5927\u65b9\u5411\u79fb\u52a8\uff0c\u5176\u4f59\u4eba\u53e3\u7559\u5728\u539f\u5730     population = cellularautomata.migrate_population_disperse(data_list, population, 4, [0.5, 0.25, 0.125, 0])     print(f\"Iteration {i + 1} is complete.\")      # \u5f53\u8fed\u4ee3\u6b21\u6570\u662f 10 \u7684\u500d\u6570\u65f6\uff0c\u5c06\u8fed\u4ee3\u7ed3\u679c\u8f93\u51fa\u4e3a\u6805\u683c\u6570\u636e     if (i + 1) % 10 == 0:         # process_raster_data() \u8fd0\u884c\u7ed3\u675f\u540e\uff0c\u8f93\u51fa\u6805\u683c\u7684 NoData \u503c\u4e3a population \u5217\u8868\u4e2d\u7684 0         rasterconvert.process_raster_data(input_raster_path, f\"Data/iterations_{i + 1}.tif\", population, 0) <p>\u5982\u9700\u5728\u5b8c\u6210\u6240\u6709\u8fed\u4ee3\u540e\u5bfc\u51fa\u6805\u683c\u6570\u636e\uff0c\u8bf7\u4f7f\u7528 run_iterations_num() \u51fd\u6570\u6216 run_iterations_pop() \u51fd\u6570\u3002</p> <p>cellularautomata.run_iterations_num(iterations, data_list, population_num=10, direction_num=4, type_migration=\"focus\", migration_proportion=1)\uff1a</p> <ul> <li>\u4f7f\u7528 \u7edf\u4e00\u7684\u521d\u59cb\u4eba\u53e3\u6570 \u8fd0\u884c\u5143\u80de\u81ea\u52a8\u673a\uff0c\u6839\u636e\u73af\u5883\u6570\u636e\u6805\u683c\u6a21\u62df\u4eba\u53e3\u8fc1\u79fb\u3002</li> </ul> In\u00a0[\u00a0]: Copied! <pre># \u8fd0\u884c\u5143\u80de\u81ea\u52a8\u673a\u6a21\u62df 5 \u6b21\u8fed\u4ee3\uff0c\u6bcf\u4e2a\u6805\u683c\u50cf\u5143\u7684\u521d\u59cb\u4eba\u53e3\u6570\u91cf\u4e3a 10\nnew_data = cellularautomata.run_iterations_num(5, data_list, population_num=10)\n\nrasterconvert.process_raster_data(input_raster_path, output_raster_path, new_data, 0)\n</pre> # \u8fd0\u884c\u5143\u80de\u81ea\u52a8\u673a\u6a21\u62df 5 \u6b21\u8fed\u4ee3\uff0c\u6bcf\u4e2a\u6805\u683c\u50cf\u5143\u7684\u521d\u59cb\u4eba\u53e3\u6570\u91cf\u4e3a 10 new_data = cellularautomata.run_iterations_num(5, data_list, population_num=10)  rasterconvert.process_raster_data(input_raster_path, output_raster_path, new_data, 0) <p>cellularautomata.run_iterations_pop(iterations, data_list, population_list, direction_num=4, type_migration=\"focus\", migration_proportion=1)\uff1a</p> <ul> <li>\u57fa\u4e8e \u521d\u59cb\u4eba\u53e3\u6570\u91cf\u6805\u683c \u8fd0\u884c\u5143\u80de\u81ea\u52a8\u673a\uff0c\u6839\u636e\u73af\u5883\u6570\u636e\u6805\u683c\u6a21\u62df\u4eba\u53e3\u8fc1\u79fb\u3002</li> </ul> In\u00a0[\u00a0]: Copied! <pre>population_file = \"Data/population.tif\"\npopulation_list = rasterconvert.raster_list(population_file)\n\n# \u8fd0\u884c\u7ec6\u80de\u81ea\u52a8\u673a\u6a21\u62df 5 \u6b21\u8fed\u4ee3\uff0c\u6bcf\u4e2a\u6805\u683c\u50cf\u5143\u7684\u521d\u59cb\u4eba\u53e3\u5927\u5c0f\u7531\u4eba\u53e3\u6805\u683c\u503c\u5217\u8868\u786e\u5b9a\nnew_data = cellularautomata.run_iterations_pop(5, data_list, population_list)\n\nrasterconvert.process_raster_data(input_raster_path, output_raster_path, new_data, 0)\n</pre> population_file = \"Data/population.tif\" population_list = rasterconvert.raster_list(population_file)  # \u8fd0\u884c\u7ec6\u80de\u81ea\u52a8\u673a\u6a21\u62df 5 \u6b21\u8fed\u4ee3\uff0c\u6bcf\u4e2a\u6805\u683c\u50cf\u5143\u7684\u521d\u59cb\u4eba\u53e3\u5927\u5c0f\u7531\u4eba\u53e3\u6805\u683c\u503c\u5217\u8868\u786e\u5b9a new_data = cellularautomata.run_iterations_pop(5, data_list, population_list)  rasterconvert.process_raster_data(input_raster_path, output_raster_path, new_data, 0) <p>cellularautomata.migrate_time(data_list, cost_list)\uff1a</p> <ul> <li>\u6839\u636e\u6210\u672c\u8def\u5f84\u6805\u683c\u53ca\u73af\u5883\u6805\u683c\u8ba1\u7b97\u8fc1\u79fb\u65f6\u95f4\u3002</li> </ul> In\u00a0[\u00a0]: Copied! <pre>cost_file = \"Data/CostPath.tif\"\ncost_list = rasterconvert.raster_list(cost_file)\n\n# \u8f93\u51fa\u8fc1\u79fb\u65f6\u95f4\u3001\u8fed\u4ee3\u6b21\u6570\u53ca\u6210\u672c\u8def\u5f84\u5bf9\u5e94\u73af\u5883\u6805\u683c\u503c\u5217\u8868\ntime, count, costData_list = cellularautomata.migrate_time(data_list, cost_list)\nprint(time, count)\nprint(costData_list, len(costData_list))\n</pre> cost_file = \"Data/CostPath.tif\" cost_list = rasterconvert.raster_list(cost_file)  # \u8f93\u51fa\u8fc1\u79fb\u65f6\u95f4\u3001\u8fed\u4ee3\u6b21\u6570\u53ca\u6210\u672c\u8def\u5f84\u5bf9\u5e94\u73af\u5883\u6805\u683c\u503c\u5217\u8868 time, count, costData_list = cellularautomata.migrate_time(data_list, cost_list) print(time, count) print(costData_list, len(costData_list))"},{"location":"examples/02_multiRaster_listDict/","title":"02 multiRaster listDict (English)","text":"<p>Uncomment the following line to install geoca, tqdm, and pymannkendall if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geoca tqdm pymannkendall\n</pre> # !pip install geoca tqdm pymannkendall <p>Import modules: rasterconvert, tqdm, and pymannkendall.</p> <p>Use rasterconvert to convert the raster data format, tqdm to create a progress bar when running the program, and pymannkendall to perform MK trend tests.</p> In\u00a0[\u00a0]: Copied! <pre>from geoca import rasterconvert\nfrom tqdm import tqdm\nimport pymannkendall as mk\n</pre> from geoca import rasterconvert from tqdm import tqdm import pymannkendall as mk <p>rasterconvert.multiRaster_listDict(folder_path, index_list):</p> <ul> <li>Reads multiple raster data (.tif) from a folder and stores it in a dictionary based on specific index values.</li> </ul> <p>The example data is the precipitation raster data of a region from 1961-2022, read the data of each year by multiRaster_listDict function, and input the raster into the data dictionary in the form of list.</p> In\u00a0[\u00a0]: Copied! <pre>index_list = list(range(1961, 2022 + 1))\ndata_dict = rasterconvert.multiRaster_listDict(\"../Pre_Year_NE\", index_list)\n</pre> index_list = list(range(1961, 2022 + 1)) data_dict = rasterconvert.multiRaster_listDict(\"../Pre_Year_NE\", index_list) In\u00a0[\u00a0]: Copied! <pre># Output the list of 2011 data in the result dictionary line by line\n# Example of the list of 2011 data: [[None, 1, 2],[4, 5, 3],[7, 6, None]]\nfor row in data_dict[2011]:\n    print(row)\n</pre> # Output the list of 2011 data in the result dictionary line by line # Example of the list of 2011 data: [[None, 1, 2],[4, 5, 3],[7, 6, None]] for row in data_dict[2011]:     print(row) <p>rasterconvert.reorganize_multiRaster_listDict(data_dict, index_list):</p> <ul> <li>Reorganizes data from a list dictionary representing multiple raster data on the basis of the multiRaster_listDict function.</li> </ul> In\u00a0[\u00a0]: Copied! <pre>data_index_list, data_value_dict = rasterconvert.reorganize_multiRaster_listDict(data_dict, index_list)\n</pre> data_index_list, data_value_dict = rasterconvert.reorganize_multiRaster_listDict(data_dict, index_list) In\u00a0[\u00a0]: Copied! <pre># Output data_index_list list line by line\n# The list is a two-dimensional indexed list with the same number of rows and columns as the original raster data, and the list element values are tuples of horizontal and vertical coordinates\n# Example of the data_index_list list: [[(1, 1), (1, 2), (1, 3)],[(2, 1), (2, 2), (2, 3)],[(3, 1), (3, 2), (3, 3)]]\nfor row in data_index_list:\n    print(row)\n</pre> # Output data_index_list list line by line # The list is a two-dimensional indexed list with the same number of rows and columns as the original raster data, and the list element values are tuples of horizontal and vertical coordinates # Example of the data_index_list list: [[(1, 1), (1, 2), (1, 3)],[(2, 1), (2, 2), (2, 3)],[(3, 1), (3, 2), (3, 3)]] for row in data_index_list:     print(row) In\u00a0[\u00a0]: Copied! <pre># Outputs the first key-value pair in the data_value_dict dictionary that does not contain None in the value\n# The dictionary with the key being the coordinate tuple (index list element value) and the value being a list of all raster image element values corresponding to the coordinates (in index_list order)\n# Example of output: (2, 3): [3, 2, 6, 7, 9]\nfor index, data_list in data_value_dict.items():\n    if None in data_list:\n        continue\n    print(f\"{index}: {data_list}\")\n    break\n</pre> # Outputs the first key-value pair in the data_value_dict dictionary that does not contain None in the value # The dictionary with the key being the coordinate tuple (index list element value) and the value being a list of all raster image element values corresponding to the coordinates (in index_list order) # Example of output: (2, 3): [3, 2, 6, 7, 9] for index, data_list in data_value_dict.items():     if None in data_list:         continue     print(f\"{index}: {data_list}\")     break <p>Once the conversion is complete, the corresponding multiple raster pixel values can be overlaid and analyzed based on these data. For example, the pymannkendall module is used to perform an MK trend test on the time-series meteorological raster data to obtain the Slope value of each image element:</p> In\u00a0[\u00a0]: Copied! <pre># Create an empty list template based on the number of rows and columns of any list in the data_dict dictionary\nkey1 = list(data_dict.keys())[0]\nlist1 = data_dict[key1]\nrows, cols = len(list1), len(list1[0])\nslope_list = [[None for _ in range(cols)] for _ in range(rows)]\n\n# Iterate through the data_value_dict dictionary, perform an MK trend test on the lists in the dictionary,\n# and add Slope values to the corresponding positions in the list templates in sequence\nfor index, data_list in tqdm(data_value_dict.items()):\n    if None in data_list:\n        continue\n    i, j = index\n    mkTest = mk.original_test(data_list)\n    slope_list[i][j] = mkTest.slope\n</pre> # Create an empty list template based on the number of rows and columns of any list in the data_dict dictionary key1 = list(data_dict.keys())[0] list1 = data_dict[key1] rows, cols = len(list1), len(list1[0]) slope_list = [[None for _ in range(cols)] for _ in range(rows)]  # Iterate through the data_value_dict dictionary, perform an MK trend test on the lists in the dictionary, # and add Slope values to the corresponding positions in the list templates in sequence for index, data_list in tqdm(data_value_dict.items()):     if None in data_list:         continue     i, j = index     mkTest = mk.original_test(data_list)     slope_list[i][j] = mkTest.slope <p>rasterconvert.process_raster_data(input_raster_path, output_raster_path, new_data, nodata_value):</p> <ul> <li>Create a raster template based on the input raster, process the raster data by replacing pixel values with the new data.</li> </ul> In\u00a0[\u00a0]: Copied! <pre>rasterconvert.process_raster_data(\"../Pre_Year_NE/Pre_2011.tif\", \"../MKData/mkSlope.tif\", slope_list, None)\n</pre> rasterconvert.process_raster_data(\"../Pre_Year_NE/Pre_2011.tif\", \"../MKData/mkSlope.tif\", slope_list, None)"},{"location":"examples/02_multiRaster_listDict.zh/","title":"02 multiRaster listDict.zh (\u7b80\u4f53\u4e2d\u6587)","text":"<p>\u5982\u6709\u9700\u8981\uff0c\u8bf7\u53d6\u6d88\u4e0b\u884c\u6ce8\u91ca\uff0c\u4ee5\u5b89\u88c5 geoca\u3001tqdm \u548c pymannkendall\u3002</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geoca tqdm pymannkendall\n</pre> # !pip install geoca tqdm pymannkendall <p>\u5bfc\u5165\u6a21\u5757\uff1arasterconvert\u3001tqdm \u548c pymannkendall\u3002</p> <p>\u4f7f\u7528 rasterconvert \u8f6c\u6362\u6805\u683c\u6570\u636e\u683c\u5f0f\uff0c\u4f7f\u7528 tqdm \u5728\u8fd0\u884c\u7a0b\u5e8f\u65f6\u521b\u5efa\u8fdb\u5ea6\u6761\uff0c\u4f7f\u7528 pymannkendall \u6267\u884c MK \u8d8b\u52bf\u68c0\u9a8c\u3002</p> In\u00a0[\u00a0]: Copied! <pre>from geoca import rasterconvert\nfrom tqdm import tqdm\nimport pymannkendall as mk\n</pre> from geoca import rasterconvert from tqdm import tqdm import pymannkendall as mk <p>rasterconvert.multiRaster_listDict(folder_path, index_list)\uff1a</p> <ul> <li>\u4ece\u6587\u4ef6\u5939\u4e2d\u8bfb\u53d6\u591a\u4e2a tif \u683c\u5f0f\u6805\u683c\u6570\u636e\uff0c\u5e76\u6839\u636e\u7279\u5b9a\u7684\u7d22\u5f15\u503c\u5c06\u5176\u5b58\u50a8\u5230\u5b57\u5178\u4e2d\u3002</li> </ul> <p>\u793a\u4f8b\u6570\u636e\u4e3a\u67d0\u5730\u533a 1961-2022 \u5e74\u7684\u964d\u6c34\u91cf\u6805\u683c\u6570\u636e\uff0c\u901a\u8fc7 multiRaster_listDict \u51fd\u6570\u8bfb\u53d6\u6bcf\u5e74\u7684\u6570\u636e\uff0c\u5e76\u4ee5\u5217\u8868\u5f62\u5f0f\u5c06\u6805\u683c\u8f93\u5165\u6570\u636e\u5b57\u5178\u3002</p> In\u00a0[\u00a0]: Copied! <pre>index_list = list(range(1961, 2022 + 1))\ndata_dict = rasterconvert.multiRaster_listDict(\"../Pre_Year\", index_list)\n</pre> index_list = list(range(1961, 2022 + 1)) data_dict = rasterconvert.multiRaster_listDict(\"../Pre_Year\", index_list) In\u00a0[\u00a0]: Copied! <pre># \u5728\u7ed3\u679c\u5b57\u5178\u4e2d\u9010\u884c\u8f93\u51fa 2011 \u5e74\u6570\u636e\u5217\u8868\n# 2011 \u5e74\u6570\u636e\u5217\u8868\u793a\u4f8b\uff1a[[None, 1, 2],[4, 5, 3],[7, 6, None]]\nfor row in data_dict[2011]:\n    print(row)\n</pre> # \u5728\u7ed3\u679c\u5b57\u5178\u4e2d\u9010\u884c\u8f93\u51fa 2011 \u5e74\u6570\u636e\u5217\u8868 # 2011 \u5e74\u6570\u636e\u5217\u8868\u793a\u4f8b\uff1a[[None, 1, 2],[4, 5, 3],[7, 6, None]] for row in data_dict[2011]:     print(row) <p>rasterconvert.reorganize_multiRaster_listDict(data_dict, index_list)\uff1a</p> <ul> <li>\u4ee5 multiRaster_listDict \u51fd\u6570\u4e3a\u57fa\u7840\uff0c\u5bf9\u8f93\u5165\u7684\u5b57\u5178\u6570\u636e\u8fdb\u884c\u91cd\u6784\uff0c\u4ee5\u4fbf\u4e8e\u540e\u7eed\u5904\u7406\u3002</li> </ul> In\u00a0[\u00a0]: Copied! <pre>data_index_list, data_value_dict = rasterconvert.reorganize_multiRaster_listDict(data_dict, index_list)\n</pre> data_index_list, data_value_dict = rasterconvert.reorganize_multiRaster_listDict(data_dict, index_list) In\u00a0[\u00a0]: Copied! <pre># \u9010\u884c\u8f93\u51fa data_index_list \u5217\u8868\n# \u8be5\u5217\u8868\u4e3a\u4e8c\u7ef4\u7d22\u5f15\u5217\u8868\uff0c\u884c\u5217\u6570\u4e0e\u539f\u59cb\u6805\u683c\u6570\u636e\u76f8\u540c\uff0c\u5143\u7d20\u503c\u4e3a\u6c34\u5e73\u5750\u6807\u548c\u5782\u76f4\u5750\u6807\u7684\u5143\u7ec4\n# data_index_list \u5217\u8868\u793a\u4f8b\uff1a [[(1, 1), (1, 2), (1, 3)],[(2, 1), (2, 2), (2, 3)],[(3, 1), (3, 2), (3, 3)]]\nfor row in data_index_list:\n    print(row)\n</pre> # \u9010\u884c\u8f93\u51fa data_index_list \u5217\u8868 # \u8be5\u5217\u8868\u4e3a\u4e8c\u7ef4\u7d22\u5f15\u5217\u8868\uff0c\u884c\u5217\u6570\u4e0e\u539f\u59cb\u6805\u683c\u6570\u636e\u76f8\u540c\uff0c\u5143\u7d20\u503c\u4e3a\u6c34\u5e73\u5750\u6807\u548c\u5782\u76f4\u5750\u6807\u7684\u5143\u7ec4 # data_index_list \u5217\u8868\u793a\u4f8b\uff1a [[(1, 1), (1, 2), (1, 3)],[(2, 1), (2, 2), (2, 3)],[(3, 1), (3, 2), (3, 3)]] for row in data_index_list:     print(row) In\u00a0[\u00a0]: Copied! <pre># \u8f93\u51fa data_value_dict \u5b57\u5178\u4e2d\u7b2c\u4e00\u4e2a\u503c\u4e2d\u4e0d\u5305\u542b None \u7684\u952e\u503c\u5bf9\n# \u8be5\u5b57\u5178\u7684\u952e\u4e3a\u5750\u6807\u5143\u7ec4\uff08data_index_list \u5217\u8868\u5143\u7d20\u503c\uff09\uff0c\u503c\u662f\u4e0e\u5750\u6807\u76f8\u5bf9\u5e94\u7684\u6240\u6709\u6805\u683c\u56fe\u50cf\u5143\u7d20\u503c\u7684\u5217\u8868\uff08\u6309 index_list \u5217\u8868\u987a\u5e8f\u6392\u5217\uff09\n# \u8f93\u51fa\u793a\u4f8b\uff1a(2, 3): [3, 2, 6, 7, 9]\nfor index, data_list in data_value_dict.items():\n    if None in data_list:\n        continue\n    print(f\"{index}: {data_list}\")\n    break\n</pre> # \u8f93\u51fa data_value_dict \u5b57\u5178\u4e2d\u7b2c\u4e00\u4e2a\u503c\u4e2d\u4e0d\u5305\u542b None \u7684\u952e\u503c\u5bf9 # \u8be5\u5b57\u5178\u7684\u952e\u4e3a\u5750\u6807\u5143\u7ec4\uff08data_index_list \u5217\u8868\u5143\u7d20\u503c\uff09\uff0c\u503c\u662f\u4e0e\u5750\u6807\u76f8\u5bf9\u5e94\u7684\u6240\u6709\u6805\u683c\u56fe\u50cf\u5143\u7d20\u503c\u7684\u5217\u8868\uff08\u6309 index_list \u5217\u8868\u987a\u5e8f\u6392\u5217\uff09 # \u8f93\u51fa\u793a\u4f8b\uff1a(2, 3): [3, 2, 6, 7, 9] for index, data_list in data_value_dict.items():     if None in data_list:         continue     print(f\"{index}: {data_list}\")     break <p>\u8f6c\u6362\u5b8c\u6210\u540e\uff0c\u53ef\u6839\u636e\u8fd9\u4e9b\u6570\u636e\u5bf9\u76f8\u5e94\u7684\u591a\u4e2a\u6805\u683c\u50cf\u5143\u503c\u8fdb\u884c\u53e0\u52a0\u5206\u6790\u3002\u4f8b\u5982\uff0cpymannkendall \u6a21\u5757\u53ef\u7528\u4e8e\u5bf9\u65f6\u95f4\u5e8f\u5217\u6c14\u8c61\u6805\u683c\u6570\u636e\u8fdb\u884c MK \u8d8b\u52bf\u68c0\u9a8c\uff0c\u4ee5\u83b7\u5f97\u6bcf\u4e2a\u56fe\u50cf\u5143\u7d20\u7684 slope \u503c\uff1a</p> In\u00a0[\u00a0]: Copied! <pre># \u6839\u636e data_dict \u5b57\u5178\u4e2d\u4efb\u610f\u5217\u8868\u7684\u884c\u5217\u6570\u521b\u5efa\u7a7a\u5217\u8868\u6a21\u677f\nkey1 = list(data_dict.keys())[0]\nlist1 = data_dict[key1]\nrows, cols = len(list1), len(list1[0])\nslope_list = [[None for _ in range(cols)] for _ in range(rows)]\n\n# \u904d\u5386 data_value_dict \u5b57\u5178\uff0c\u5bf9\u5b57\u5178\u4e2d\u7684\u5217\u8868\u6267\u884c MK \u8d8b\u52bf\u68c0\u9a8c\uff0c\u5e76\u5c06 slope \u4f9d\u6b21\u6dfb\u52a0\u5230\u5217\u8868\u6a21\u677f\u4e2d\u7684\u5bf9\u5e94\u4f4d\u7f6e\nfor index, data_list in tqdm(data_value_dict.items()):\n    if None in data_list:\n        continue\n    i, j = index\n    mkTest = mk.original_test(data_list)\n    slope_list[i][j] = mkTest.slope\n</pre> # \u6839\u636e data_dict \u5b57\u5178\u4e2d\u4efb\u610f\u5217\u8868\u7684\u884c\u5217\u6570\u521b\u5efa\u7a7a\u5217\u8868\u6a21\u677f key1 = list(data_dict.keys())[0] list1 = data_dict[key1] rows, cols = len(list1), len(list1[0]) slope_list = [[None for _ in range(cols)] for _ in range(rows)]  # \u904d\u5386 data_value_dict \u5b57\u5178\uff0c\u5bf9\u5b57\u5178\u4e2d\u7684\u5217\u8868\u6267\u884c MK \u8d8b\u52bf\u68c0\u9a8c\uff0c\u5e76\u5c06 slope \u4f9d\u6b21\u6dfb\u52a0\u5230\u5217\u8868\u6a21\u677f\u4e2d\u7684\u5bf9\u5e94\u4f4d\u7f6e for index, data_list in tqdm(data_value_dict.items()):     if None in data_list:         continue     i, j = index     mkTest = mk.original_test(data_list)     slope_list[i][j] = mkTest.slope <p>rasterconvert.process_raster_data(input_raster_path, output_raster_path, new_data, nodata_value)\uff1a</p> <ul> <li>\u6839\u636e\u8f93\u5165\u6805\u683c\u521b\u5efa\u6805\u683c\u6a21\u677f\uff0c\u5e76\u7528\u65b0\u6570\u636e\u66ff\u6362\u50cf\u7d20\u503c\u6765\u5904\u7406\u6805\u683c\u6570\u636e\u3002</li> </ul> In\u00a0[\u00a0]: Copied! <pre>rasterconvert.process_raster_data(\"../Pre_Year/Pre_2011.tif\", \"../MKData/mkSlope.tif\", slope_list, None)\n</pre> rasterconvert.process_raster_data(\"../Pre_Year/Pre_2011.tif\", \"../MKData/mkSlope.tif\", slope_list, None)"}]}